import { Injectable, Logger, BadRequestException, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between, MoreThan } from 'typeorm';
import { ConfigService } from '@nestjs/config';
import OpenAI from 'openai';
import { AiInsight, InsightType, InsightPriority } from './entities/ai-insight.entity.js';
import { CreateAiInsightDto } from './dto/create-ai-insight.dto.js';
import { UpdateAiInsightDto } from './dto/update-ai-insight.dto.js';
import { GenerateInsightDto } from './dto/generate-insight.dto.js';
import { ActivityMetric } from '../health/activity/activity-metric.entity.js';
import { SleepMetric } from '../health/sleep/sleep-metric.entity.js';
import { NutritionMetric } from '../health/nutrition/nutrition-metric.entity.js';
import { User } from '../user/entities/user.entity.js';

interface GenerationLimitCheck {
  canGenerate: boolean;
  nextAvailableTime?: Date;
  remainingGenerations: number;
}

@Injectable()
export class AiInsightsService {
  private readonly logger = new Logger(AiInsightsService.name);
  private readonly openai: OpenAI;

  constructor(
    @InjectRepository(AiInsight)
    private aiInsightRepository: Repository<AiInsight>,
    @InjectRepository(ActivityMetric)
    private activityRepository: Repository<ActivityMetric>,
    @InjectRepository(SleepMetric)
    private sleepRepository: Repository<SleepMetric>,
    @InjectRepository(NutritionMetric)
    private nutritionRepository: Repository<NutritionMetric>,
    @InjectRepository(User)
    private userRepository: Repository<User>,
    private configService: ConfigService,
  ) {
    const apiKey = this.configService.get<string>('OPENAI_API_KEY');
    if (!apiKey) {
      this.logger.warn('OpenAI API key not found. AI insights will be disabled.');
    } else {
      this.openai = new OpenAI({
        apiKey: apiKey,
      });
    }
  }

  async create(userId: number, createAiInsightDto: CreateAiInsightDto): Promise<AiInsight> {
    const insight = this.aiInsightRepository.create({
      ...createAiInsightDto,
      userId,
      insightDate: new Date(createAiInsightDto.insightDate),
    });

    return await this.aiInsightRepository.save(insight);
  }

  async findAll(userId: number, limit: number = 50): Promise<AiInsight[]> {
    return await this.aiInsightRepository.find({
      where: { userId },
      order: { createdAt: 'DESC' },
      take: limit,
    });
  }

  async findOne(userId: number, id: number): Promise<AiInsight> {
    const insight = await this.aiInsightRepository.findOne({
      where: { id, userId },
    });

    if (!insight) {
      throw new NotFoundException(`AI insight with ID ${id} not found`);
    }

    return insight;
  }

  async update(userId: number, id: number, updateAiInsightDto: UpdateAiInsightDto): Promise<AiInsight> {
    const insight = await this.findOne(userId, id);
    
    Object.assign(insight, updateAiInsightDto);
    
    if (updateAiInsightDto.insightDate) {
      insight.insightDate = new Date(updateAiInsightDto.insightDate);
    }

    return await this.aiInsightRepository.save(insight);
  }

  async remove(userId: number, id: number): Promise<void> {
    const insight = await this.findOne(userId, id);
    await this.aiInsightRepository.remove(insight);
  }

  async markAsRead(userId: number, id: number): Promise<AiInsight> {
    return await this.update(userId, id, { isRead: true });
  }

  async markAsDismissed(userId: number, id: number): Promise<AiInsight> {
    return await this.update(userId, id, { isDismissed: true });
  }

  async checkGenerationLimit(userId: number): Promise<GenerationLimitCheck> {
    const now = new Date();
    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);

    // Count insights generated by AI (not manually created) in the last 24 hours
    const recentGenerations = await this.aiInsightRepository.count({
      where: {
        userId,
        createdAt: MoreThan(last24Hours),
        // Assume AI-generated insights have confidence scores
        confidenceScore: MoreThan(0),
      },
    });

    const maxGenerationsPerDay = 3;
    const remainingGenerations = Math.max(0, maxGenerationsPerDay - recentGenerations);

    if (recentGenerations >= maxGenerationsPerDay) {
      // Find the oldest generation in the last 24 hours to calculate when next generation is available
      const oldestGeneration = await this.aiInsightRepository.findOne({
        where: {
          userId,
          createdAt: MoreThan(last24Hours),
          confidenceScore: MoreThan(0),
        },
        order: { createdAt: 'ASC' },
      });

      const nextAvailableTime = oldestGeneration 
        ? new Date(oldestGeneration.createdAt.getTime() + 24 * 60 * 60 * 1000)
        : new Date(now.getTime() + 6 * 60 * 60 * 1000); // 6 hours default

      return {
        canGenerate: false,
        nextAvailableTime,
        remainingGenerations: 0,
      };
    }

    // Check 6-hour interval
    const last6Hours = new Date(now.getTime() - 6 * 60 * 60 * 1000);
    const recentInSixHours = await this.aiInsightRepository.count({
      where: {
        userId,
        createdAt: MoreThan(last6Hours),
        confidenceScore: MoreThan(0),
      },
    });

    if (recentInSixHours > 0) {
      const lastGeneration = await this.aiInsightRepository.findOne({
        where: {
          userId,
          createdAt: MoreThan(last6Hours),
          confidenceScore: MoreThan(0),
        },
        order: { createdAt: 'DESC' },
      });

      const nextAvailableTime = lastGeneration
        ? new Date(lastGeneration.createdAt.getTime() + 6 * 60 * 60 * 1000)
        : new Date(now.getTime() + 6 * 60 * 60 * 1000);

      return {
        canGenerate: false,
        nextAvailableTime,
        remainingGenerations,
      };
    }

    return {
      canGenerate: true,
      remainingGenerations,
    };
  }

  async generateInsight(userId: number, generateDto: GenerateInsightDto): Promise<AiInsight> {
    // Check rate limits
    const limitCheck = await this.checkGenerationLimit(userId);
    if (!limitCheck.canGenerate) {
      throw new BadRequestException(
        `Generation limit reached. Next available generation: ${limitCheck.nextAvailableTime?.toISOString()}. Remaining generations today: ${limitCheck.remainingGenerations}`
      );
    }

    if (!this.openai) {
      throw new BadRequestException('AI insights are currently unavailable');
    }

    const targetDate = generateDto.date ? new Date(generateDto.date) : new Date();
    const user = await this.userRepository.findOne({ where: { id: userId } });
    
    if (!user) {
      throw new NotFoundException('User not found');
    }

    // Gather health data for the target date and surrounding context
    const healthData = await this.gatherHealthData(userId, targetDate);
    
    // Generate insight using OpenAI
    const insightType = generateDto.type || InsightType.DAILY_SUMMARY;
    const aiResponse = await this.generateAIInsight(healthData, insightType, user);

    // Save the generated insight
    const createDto: CreateAiInsightDto = {
      type: insightType,
      title: aiResponse.title,
      content: aiResponse.content,
      priority: aiResponse.priority,
      recommendations: aiResponse.recommendations,
      confidenceScore: aiResponse.confidenceScore,
      insightDate: targetDate.toISOString(),
      metadata: {
        generatedAt: new Date().toISOString(),
        dataPoints: healthData.dataPointsCount,
        aiModel: 'gpt-4',
      },
    };

    return await this.create(userId, createDto);
  }

  private async gatherHealthData(userId: number, targetDate: Date) {
    const startOfDay = new Date(targetDate);
    startOfDay.setHours(0, 0, 0, 0);
    
    const endOfDay = new Date(targetDate);
    endOfDay.setHours(23, 59, 59, 999);

    // Get data for the target date
    const [dayActivity, daySleep, dayNutrition] = await Promise.all([
      this.activityRepository.find({
        where: { userId, date: Between(startOfDay, endOfDay) },
        order: { createdAt: 'DESC' },
      }),
      this.sleepRepository.find({
        where: { userId, date: Between(startOfDay, endOfDay) },
        order: { createdAt: 'DESC' },
      }),
      this.nutritionRepository.find({
        where: { userId, date: Between(startOfDay, endOfDay) },
        order: { createdAt: 'DESC' },
      }),
    ]);

    // Get historical data for context (last 7 days)
    const weekAgo = new Date(targetDate.getTime() - 7 * 24 * 60 * 60 * 1000);
    
    const [weekActivity, weekSleep, weekNutrition] = await Promise.all([
      this.activityRepository.find({
        where: { userId, date: Between(weekAgo, endOfDay) },
        order: { date: 'DESC' },
      }),
      this.sleepRepository.find({
        where: { userId, date: Between(weekAgo, endOfDay) },
        order: { date: 'DESC' },
      }),
      this.nutritionRepository.find({
        where: { userId, date: Between(weekAgo, endOfDay) },
        order: { date: 'DESC' },
      }),
    ]);

    return {
      targetDate,
      day: {
        activity: dayActivity,
        sleep: daySleep,
        nutrition: dayNutrition,
      },
      week: {
        activity: weekActivity,
        sleep: weekSleep,
        nutrition: weekNutrition,
      },
      dataPointsCount: dayActivity.length + daySleep.length + dayNutrition.length,
    };
  }

  private async generateAIInsight(healthData: any, type: InsightType, user: User) {
    const prompt = this.buildPrompt(healthData, type, user);
    
    try {
      const completion = await this.openai.chat.completions.create({
        model: 'gpt-4o-mini', // More cost-effective model
        messages: [
          {
            role: 'system',
            content: 'You are a health and wellness AI assistant that provides personalized insights based on user health data. Always provide actionable, encouraging, and evidence-based recommendations.',
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.7,
        max_tokens: 500,
      });

      const response = completion.choices[0]?.message?.content;
      if (!response) {
        throw new Error('No response from OpenAI');
      }

      return this.parseAIResponse(response, type);
    } catch (error) {
      this.logger.error('Failed to generate AI insight:', error);
      throw new BadRequestException('Failed to generate AI insight');
    }
  }

  private buildPrompt(healthData: any, type: InsightType, user: User): string {
    const { day, week, targetDate } = healthData;
    
    let prompt = `Analyze the following health data for ${user.email} on ${targetDate.toDateString()}:\n\n`;
    
    // Add daily data
    prompt += `TODAY'S DATA:\n`;
    prompt += `Activities: ${day.activity.length > 0 ? day.activity.map(a => `${a.activityType} for ${a.duration} minutes (Heart Rate: ${a.averageHeartRate || 'N/A'} bpm)`).join(', ') : 'No activities logged'}\n`;
    prompt += `Sleep: ${day.sleep.length > 0 ? day.sleep.map(s => `${s.duration ? Math.round(s.duration / 60) : 'N/A'} hours, quality: ${s.quality}`).join(', ') : 'No sleep data'}\n`;
    prompt += `Nutrition: ${day.nutrition.length > 0 ? day.nutrition.map(n => `${n.foodName} (${n.calories || 'N/A'} cal)`).join(', ') : 'No nutrition logged'}\n\n`;
    
    // Add weekly context
    if (week.activity.length > 0 || week.sleep.length > 0 || week.nutrition.length > 0) {
      prompt += `WEEKLY CONTEXT (last 7 days):\n`;
      if (week.activity.length > 0) {
        const avgHeartRate = week.activity
          .filter(a => a.averageHeartRate)
          .reduce((sum, a) => sum + a.averageHeartRate, 0) / week.activity.filter(a => a.averageHeartRate).length;
        prompt += `- ${week.activity.length} activities logged, average heart rate: ${avgHeartRate ? Math.round(avgHeartRate) : 'N/A'} bpm\n`;
      }
      if (week.sleep.length > 0) {
        const avgSleep = week.sleep
          .filter(s => s.duration)
          .reduce((sum, s) => sum + s.duration, 0) / week.sleep.filter(s => s.duration).length / 60;
        prompt += `- Average sleep: ${avgSleep ? avgSleep.toFixed(1) : 'N/A'} hours\n`;
      }
      prompt += '\n';
    }

    // Add specific instructions based on insight type
    switch (type) {
      case InsightType.DAILY_SUMMARY:
        prompt += `Provide a brief daily summary with 2-3 actionable recommendations. Focus on patterns and improvements.`;
        break;
      case InsightType.HEALTH_TREND:
        prompt += `Identify any notable health trends or patterns. Highlight positive changes and areas for improvement.`;
        break;
      case InsightType.RECOMMENDATION:
        prompt += `Provide specific, actionable health recommendations based on the data patterns.`;
        break;
      default:
        prompt += `Provide meaningful health insights with actionable recommendations.`;
    }

    prompt += `\n\nRespond in JSON format with: {"title": "...", "content": "...", "recommendations": ["...", "..."], "priority": "low|medium|high", "confidenceScore": 0-100}`;

    return prompt;
  }

  private parseAIResponse(response: string, type: InsightType) {
    try {
      // Try to extract JSON from the response
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('No JSON found in response');
      }

      const parsed = JSON.parse(jsonMatch[0]);
      
      return {
        title: parsed.title || `${type.replace('_', ' ')} Insight`,
        content: parsed.content || response.substring(0, 300),
        recommendations: Array.isArray(parsed.recommendations) ? parsed.recommendations : [],
        priority: parsed.priority || InsightPriority.MEDIUM,
        confidenceScore: parsed.confidenceScore || 75,
      };
    } catch (error) {
      this.logger.warn('Failed to parse AI response as JSON, using fallback:', error);
      
      // Fallback: extract basic information
      const lines = response.split('\n').filter(line => line.trim());
      const title = lines[0]?.substring(0, 100) || `${type.replace('_', ' ')} Insight`;
      const content = response.substring(0, 300);
      
      return {
        title,
        content,
        recommendations: [],
        priority: InsightPriority.MEDIUM,
        confidenceScore: 60,
      };
    }
  }

  async getInsightsByType(userId: number, type: InsightType, limit: number = 20): Promise<AiInsight[]> {
    return await this.aiInsightRepository.find({
      where: { userId, type },
      order: { createdAt: 'DESC' },
      take: limit,
    });
  }

  async getUnreadInsights(userId: number): Promise<AiInsight[]> {
    return await this.aiInsightRepository.find({
      where: { userId, isRead: false, isDismissed: false },
      order: { createdAt: 'DESC' },
    });
  }

  async generateDailyInsights(): Promise<void> {
    // This method can be called by a scheduler to generate daily insights for all users
    this.logger.log('Starting daily insights generation...');
    
    try {
      const users = await this.userRepository.find({
        select: ['id', 'email'],
      });

      for (const user of users) {
        try {
          const limitCheck = await this.checkGenerationLimit(user.id);
          if (limitCheck.canGenerate) {
            await this.generateInsight(user.id, {
              type: InsightType.DAILY_SUMMARY,
              includeRecommendations: true,
            });
            this.logger.log(`Generated daily insight for user ${user.id}`);
          }
        } catch (error) {
          this.logger.error(`Failed to generate daily insight for user ${user.id}:`, error);
        }
      }
    } catch (error) {
      this.logger.error('Failed to generate daily insights:', error);
    }
  }
}